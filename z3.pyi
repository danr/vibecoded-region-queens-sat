"""Type stubs for Z3 theorem prover library.

Note: Z3 comparison operators like == and != return BoolRef expressions, 
not Python bool values. This stub handles the most common Z3 usage patterns.
"""

from typing import Any, List, Union, Sequence, Iterator, overload

# Basic Z3 expression types
class ExprRef:
    def __sub__(self, other: Any) -> ExprRef: ...
    def __add__(self, other: Any) -> ExprRef: ...
    # Z3's comparison operators return BoolRef expressions, not bool
    def __eq__(self, other: Any) -> BoolRef: ...  # type: ignore[override]
    def __ne__(self, other: Any) -> BoolRef: ...  # type: ignore[override]

class BoolRef(ExprRef): ...
class BitVecRef(ExprRef): ...
class IntRef(ExprRef): ...
class ArithRef(ExprRef): ...

# Z3 Core Functions that create expressions
def BitVec(name: str, size: int) -> BitVecRef: ...
def Int(name: str) -> IntRef: ...
def IntVector(prefix: str, sz: int) -> list[IntRef]: ...
def Bool(name: str) -> BoolRef: ...

# Z3 constraint functions - these create BoolRef expressions
def ULT(a: BitVecRef, b: Union[int, BitVecRef]) -> BoolRef: ...

@overload
def Distinct(*args: ExprRef) -> BoolRef: ...
@overload  
def Distinct(args: Sequence[ExprRef]) -> BoolRef: ...

@overload
def And(*args: BoolRef) -> BoolRef: ...
@overload
def And(args: Sequence[BoolRef]) -> BoolRef: ...

@overload
def Or(*args: BoolRef) -> BoolRef: ...
@overload
def Or(args: Sequence[BoolRef]) -> BoolRef: ...

def Abs(a: Union[IntRef, ArithRef]) -> Union[IntRef, ArithRef]: ...

# Solver result types
class CheckSatResult: ...

sat: CheckSatResult
unsat: CheckSatResult
unknown: CheckSatResult

class Model:
    def __getitem__(self, key: ExprRef) -> Any: ...

class Solver:
    def __init__(self) -> None: ...
    def add(self, *args: Any) -> None: ...  # Accept any arguments to be flexible
    def check(self, *assumptions: BoolRef) -> CheckSatResult: ...
    def model(self) -> Model: ...
    def assertions(self) -> list[ExprRef]: ...
    def sexpr(self) -> str: ...

# Goal and Tactic classes for bit-blasting
class Goal:
    def __init__(self) -> None: ...
    def add(self, assertion: ExprRef) -> None: ...
    def dimacs(self) -> str: ...
    def sexpr(self) -> str: ...

class ApplyResult:
    def __iter__(self) -> Iterator[Goal]: ...

class Tactic:
    def __init__(self, name: str) -> None: ...
    def __call__(self, goal: Goal) -> ApplyResult: ...

def Then(*tactics: Union[str, Tactic]) -> Tactic: ...